# 4. 이미지 최적화

## 4.1 이미지의 중요성

인터넷과 고해상도 디스플레이의 발전으로 이미지 개수와 크기는 점점 많아지고 커지고 있다.

### 4.1.1 화소밀도

화소 밀도는 물리 스크린 공간 안에 얼마나 많은 픽셀이 압축되어있는가를 의미한다.

화소밀도는 1x, 2x와 같은 기기 픽셀 비율(Device Pixel Ratio, DPR)로 표현한다.

모니터나 TV의 화소 밀도는 보통 인치당 픽셀 개수인 PPI(Pixel Per Inch)로 표현한다.

1인치 안에 10개의 픽셀이 있는 A모니터의 화소 밀도는 10PPI이다.
마찬가지로 1인치 안에 20개의 픽셀이 있는 B모니터의 화소 밀도는 20PPI이다.

B모니터는 A모니터보다 인치당 2배의 픽셀이 있기 때문에 2x DPR이 된다.

단위 인치당 픽셀의 수가 2배가 많다는 것은 반대로 픽셀 크기가 1/2로 작다는 말이기 때문에 같은 픽셀수의 이미지는 B에서 A보다 1/2배 작게 보인다.

예를들어 B에서 2048픽셀 너비의 이미지가 A에서 1024 픽셀의 이미지와 같은 크기로 보인다.

또한 포인트라는 용어도 사용하는데 40픽셀의 이미지는 40픽셀 너비를 가진 이미지 하나이지만, 40포인트의 이미지는 1x에서는 40픽셀, 2x에서는 80픽셀, 3x에서는 120픽셀 너비의 이미지를 뜻한다. 즉 다른 PPI에도 같은 크기로 보일 수 있도록 대응된 이미지를 나타낸다.

## 4.2 디지털 이미지의 종류와 특성

이미지 형식의 종류와 특징을 잘 파악하고 사용 목적 및 기기에 맞는 이미지를 선택해야한다.

### 4.2.1 래스터 이미지 vs 벡터 이미지

#### 레스터이미지

래스터 이미지는 사각형 모양의 픽셀에 표현하고자 하는 색상 정보를 입력해 컴퓨터로 표현하는 방식이다.

사이즈가 크거나 품질이 좋은 이미지를 만들기 위해선 그 만큼의 정보를 담은 픽셀을 추가해야한다.

즉 확장성이 떨어진다.

#### 벡터이미지

벡터이미지는 그리고자 하는 대상의 수학적인 정보를 제공한다.

주로 svg가 많이 사용된다.

벡터이미지는 화면 스케일에 상관없이 항상 선명한 이미지를 표현할 수 있다.

하지만 복잡해지면 이를 표현하기 위한 정보가 기하급수적으로 늘어나며, 이를 수학적으로 표현하는 데에도 제약이 있다.

svg는 텍스트 기반 콘텐츠이므로 gzip이나 brotli 같은 텍스트 압축 기법으로 최적화 할 수 있다. 또한 zopfli 압축기법으로 svgz파일을 만들어 사용할 수도 있다.

### 4.2.2 무손실 이미지 형식 vs 손실 이미지 형식

원본 이미지의 정보 손실을 허용하지 않으면 무손실 이미지이다.

예) GIF, PNG

필요에 따라 정보 손실을 어느정도 허용하면 손실이미지이다.

예) JPEG, WebP, JPEG XR, JPEG 2000

손실 이미지는 단순 복사를 하거나 저장할 때도 정보 손실이 발생할 수 있기 때문에 주의해야 한다.

#### GIF

GIF는 몇 개의 이미지를 묶어 짧은 애니메이션으로 표현하는 기능을 제공한다.

사용할 수 있는 색이 256컬러 (8bit)이다.

트루컬러 GIF 타입으로 변환할 수 있으나 용량이 너무 커서 비효율적이다.

때문에 기업의 로고같은 단순한 형태의 이미지 표현에 적합하다.

#### PNG

PNG는 24비트 색상을 사용하므로 GIF보다 고품질의 이미지를 표현할 수 있다.

또한 알파채널을 지원하여 이미지의 백그라운드 투명도를 조절해 하나의 이미지에 여러 배경을 바꾸어 이미지를 다양하게 조합할 수 있따.

컬러 팔레트 PNG와 트루 컬러 PNG로 나눌 수 있고, 대부분 웹사이트에서 사용되는 PNG는 알파 채널이 추가된 트루컬러 PNG이다.

#### JPEG

JPEG는 사진을 저장하는 사실상의 표준형식이다.

사람의 눈이 인식할 수 있는 색상만 남기고 나머지를 제거하여 압축한다.

사용자가 품질값을 결정할 수 있으며 품질을 100ㅇ로 하더라도 손실이 발생한다.

때문에 편집할 때는 비트맵이나 PNG 처럼 무손실 이미지 파일을 사용하다 편집 완료하면 JPEG로 저장한다.

#### JPEG 2000

JPEG 2000은 JPEG 보다 압축률을 높였다. 무손실 압축 및 투명기능, 애니메이션 기능을 지원한다. 또한 16, 24, 32 비트의 색을 지원한다.

하지만 다양한 기능이 포함된 만큼 더 많은 프로세싱 자원이 필요하다.

그리고 대부분의 브라우저에서 지원하지 않는다.

#### WebP

WebP는 JPEG보다 압축률이 개선되었고, 무손실 압축, 애니메이션 기능, 투명 기능도 모두 지원한다.

하지만 이미지 품질을 많이 낮추면 화면에 약산의 손실이 발생한다.

그리고 JPEG와 같은 점진적 데이터 전송 기능은 갖추지 못했다.

일반적인 환경에서는 JPEG 대신 WebP를 사용하는 것이 유리하다.

#### JPEG XR

JPEG의 RGB 색상채널을 확장해서 더 많은 수의 색을 표현할 수 있도록 하였다.

무손실 압축 기능과 투명 기능을 지원하며 점진적 데이터 기능도 지원한다.

하지만 대부분의 브라우저에서 지원하지 않는다.

## 4.3 이미지 변환 기법

무손실 압축과 손실 압축에 대해서 알아보자

### 4.3.1 무손실 압축

이미지 유형마다 다르게 처리해야 한다. 하지만 스크립트로 자동화할 수 있다.

#### GIF

imageMagicK, Giflossy, Gifsicle, gif2webp converter, ImageMagicK를 사용할 수 있다.

#### PNG

PNG 임을 알리는 첫 8바이트의 서명을 제외하고 청크형태로 저장된다. 이외에도 사용자 정의 청크를 추가하고 삭제할 수 있따.

Pngcrush, Pngquant를 사용할 수 있따.

#### JPEG

JPEG 안에는 많은 메타데이터가 포함되어 있으며 이를 삭제할 수 있다.

- 주석 및 공백
- 편집 어플 정보
- 카메라, 오디오, 위치관련 정보

MozJPEG, libJpeg, Guetzli를 사용할 수 있다.

### 4.3.2 손실 압축

특정 이미지 정보를 누락시켜 파일 크기를 줄이는 방법이다.

대부분의 웹사용자들은 이미지의 화질차이보다 로딩속도에 민감하게 반응한다.

보통 80%정도 압축하는 것이 좋다.

#### 자동 최적화 도구

CDN에서 제공하는 기능을 사용 혹은 JPEGmini를 사용

#### 브라우저 특화 이미지로 변환

하나의 이미지를 만들더라도 다양한 브라우저 특화 이미지로 변환하여 제공해야한다.

### 4.4 반응형 웹에서의 이미지 배치 전략

반응형 웹을 사용하면 모바일과 데스크탑 모두 대응할 수 있다.

### 4.4.1 반응형 웹의 문제점

반응형 웹은 모바일과 데스크톱 사용자에게 똑같은 유저 경험을 제공한다는 데에 있다.

데스크톱 환경에 비해 모바일 환경은 기기 사양과 네트워크 환경이 좋지 않아 이에 대한 대응을 하지 않으면 똑같은 유저 경험을 제공할 수 없다.

### 4.4.2 원인은 이미지

반응형 웹에서 필요 이상의 웹 리소스를 과하게 내려받는 현상은 크게 세 가지 유형으로 구분할 수 있다.

#### 내려받아 줄이기

브라우저에서 큰 이미지를 다운로드 하고 작게 축소하는 처리를 한다.

이는 추가적으로 가로와 세로값을 계산하는 추가 과정 또한 필요하게 된다.

#### 내려받아 숨기기

데스크탑 환경에서만 필요한 리소스들이 모바일에서도 다운로드 되는 경우이다.

#### 화면 바깥 부분

처음 보이는 화면 바깥 부분의 이미지들은 화면에 보이지는 않지만 내려받아 숨기기 처럼 모두 다운로드 된다.

### 4.4.3 반응형 이미지

반응형 웹의 문제점을 한마디로 요약하면 모바일환경에서 필요하지 않은 리소스를 다운로드 한다는 것이다.

그리고 이 중 과도한 이미지 다운로드가 제일 큰 영향을 미친다.

반응형 이미지는 사용자의 환경 조건에 반응해 그 환경에 적합한 상태로 변경해 제공되는 이미지이다.

즉 특정 환경에서 특정 이미지를 요청하면 그 환경에 맞도록 이미 변경된 이미지가 전송되는 것이 반응형 이미지이다.

### 4.4.4 반응형 이미지 구현 방법

반응형 이미지 방법은 크게 두 가지 측면에서 접근할 수 있다.

#### 프론트엔드

미디어쿼리를 사용해 클라이언트 환경을 파악 후 그 환경에 맞는 이미지를 호출하도록 웹페이지를 구현하는 방법이다.

`<img>` 태그의 srcset 속성이나 `<picture>` 태그를 사용해서 표준방식으로 구현할 수 있다.

하지만 프론트엔드 코드가 무거워져 성능에 영향을 줄 수 있다.

#### 백엔드

서버에서 클라이언트의 환경에 맞는 이미지를 선택하여 전송하는 방법이다. 프론트엔드 코드가 추가되지 않으므로 사이트의 성능을 향상시킬 수 있다.

하지만 클라이언트 환경을 어떻게 파악할것인지 고민해야하고 서버쪽 프로그램이 추가되어야 하는 번거로움이 있다.

정확한 클라이언트 환경을 서버에 전달하기 위해 Client Hints를 이용하는 방안이 있다.

#### srcset과 size

HTML의 `<img>` 태그에 srcset을 사용하여 사용자의 호나경에 따라 다른 이미지 url을 지정할 수 있다.

```HTML
<img src="small.jpg" alt="rwd" srcset="pic-normal.jpg 1x, pic-retina.jpg 2x">
```

1x, 2x는 화소 밀도를 나타낸다. 즉 고해상도 화면 기기에서는 pic-retina가 지정된다.

또한 HTML의 `<img>` 태그에 size 속성을 사용하여 브레이크 포인트에 따른 이미지 크기를 지정할 수 있다.

size를 사용할 떄는 srcset에 1x,2x와 같은 화소 밀도 정보가 아닌 width 정보를 정의해야 한다.

```HTML
<img src="small.jpg" alt="rwd" srcset="pic-200.jpg 200w, pic-400.jpg 400w" size="(max-width: 400px) 100vw, (max-width: 800px) 30vw, 300px">
```

200w, 400w는 이미지의 width를 나타낸다.

또한 size를 사용하여 0~400 까지는 100vw, 401~801까지는 30vw로 표현되도록 했다.

srcset은 브라우저에 가장 적절한 이미지를 선택하도록 힌트를 주는 역할을 한다. 100%는 아니다.

예를들어 화면이 600px일 때 이미지의 크기인 30vw는 200px이므로 pic-normal이 선택된다.

하지만 기기가 높은 해상도를 가질 경우 pic-400이 선택될 확률이 높아진다.

하지만 브라우저의 연산 방식이나 메모리에 따라 pic-200이 선택될 수도 있다.

#### picture

`<picture>`는 내부적으로 `<source>`를 사용해서 다양한 이미지 url을 설정하게 한다.

이 때 미디어 쿼리를 사용하여 각 이미지의 로딩 조건을 정의할 수 있으며

`<img>`의 srcset과는 다르게 조건에 맞는 이미지만 사용하도록 브라우저에게 강제할 수 있다는 장점이 있다.

조건에 맞지 않는 이미지는 다운로드 하지 않는다.

하지만 사용하면 HTML 소스가 길어진다는 단점도 있다.

```HTML
<picture>
    <source media="(min-width: 45em)" srcset="large.jpg, large-hd.jpg 2x">
    <source media="(min-width: 18em)" srcset="med.jpg, med-hd.jpg 2x">
    <source srcset="small.jpg, small-hd.jpg 2x">
    <img src="small-1.jpg" alt="rwd">
</picture>
```

`<picture>`는 대부분의 브라우저를 지원한다.

#### Art direct

이미지가 기기 특징에 따라 표현되도록 하는 작업이다.

#### Client Hints

이는 웹페이지를 호스팅하는 서버에서 사용자 환경을 고려해 응답할 내용을 최적화한 후 브라우저에 전달하는 방안이다.

즉 사용자 환경을 서버에 표준 방식으로 전달하기 위해 고안된 방법이다.

Accept-Encoding과 마찬가지로 내용 협상 방식으로 동작한다.

1. 브라우저에서 최초 서버로 HTTP 요청을 보낸다.
2. 서버에서 Accept-CH를 추가해 Client Hints를 지원하고 있음을 브라우저에 알린다. 동시에 필요한 정보도 보낼것을 요청한다.

```
Accept-CH: DPR, Width ,Viewport-Width
```

브라우저에서는 요청에 관한 내용을 헤더에 추가해 보낸다.

```
DPR: 2.0
width: 320
Viewport-Width:320
```

서버는 최적화된 이미지를 전송한 후 사용한 DPR 정보를 마지막 응답 메시지로 보낸다.

#### 이미지 지연로딩

화면 바깥 이미지를 최적화하기 위해 이미지가 실제 ㄴ보일 때 다운로드 하는 방법

HTML dataSet을 이용하는 방법과 Intersection Observer API를 이용한 방법, 스크롤 이벤트를 이용한 여러 방법 등이 있다.

#### 모바일 우선 접근

모바일 사용자가 더 많아진 만큼 모바일을 우선 접근하는 전략을 사용해보자

## 4.5 적응형 이미지 전략

적응형 이미지는 서버쪽에서 사용자의 환경을 고려하여 이미지를 선택해서 전송하는 이미지 호출방식이다.

### 4.5.1 적응형 이미지 아키텍처

핵심은 다음과 같다.

1. 요청 클라이언트 정보를 감지

2. 클라이언트 맞춤형 데이터를 로딩하는 서버 로직 추가

클라이언트 정보 감지에 Client Hints는 아직 표준이 아니여서 어렵다.

대신 User-Agent 헤더를 사용하여 클라이언트 정보를 알 수 있다.

브라우저 정보, 버전, 플랫폼, 시스템, 기타 사용자 정보 등이 담겨있다.

그러므로 원본서버 앞에 리버스 프록시 서버 또는 어플리케이션을 두고 User-Agent 값을 기반으로 필요한 정보들을 수집해 사용자 정의 헤더나 쿠키에 넣어서 보낼 수 있다.

이를 기기를 감지해 정보를 제공해주는 서비스와 같이 사용하여 적응형 이미지 아키텍쳐를 사용할 수 있다.

다음과 같은 서비스들이 있다.

DeviceAtlas, ScientiaMobile/Wurf, 5ldegree

혹은 CDN을 사용하면 제공되는 기기 검출 서비스를 고려해볼 수 있다.

또한 Modermizr과 같은 클라이언트측 자바스크립트로 장치 탐지를 수행할 수 있다.

하지만 클라측 스크립트이므로 자바스크립트가 포함된 첫 페이지에는 사용할 수 없다.

### 4.5.2 기기 정보에 따라 서버 로직 수행
