# 3. 웹사이트 성능을 개선하는 기본적인 방법

## 3.1 HTTP 요청 수 줄이기

일반적으로 브라우저는 DNS 시스템으로 특정 도메인의 접속 IP를 알아내 접속을 하고 HTML 파일을 먼저 응답받은 후 HTML 내에 있는 CSS나 자바스크립트, 이미지등의 콘텐츠를 차례대로 호출한다.

즉 브라우저가 HTML을 모두 해석하여 콘텐츠를 전부 받아오기까지 호출이 계속 진행된다.

웹페이지의 콘텐츠는 동일하게 유지하며 HTTP 요청수를 줄이는 방법을 찾아야한다.

### 3.1.1 스크립트 파일 병합

소프트웨어 공학에서는 손쉬운 분업화 및 편리한 유지보수를 위해 최소 기능 단위별로 소프트웨어 모듈을 나누어 개발하는 것을 제안하는데, 이를 모듈화라고 한다.

웹서비스 개발에도 자바스크립트나 CSS등을 모듈로 분리하여 개발한다.

하지만 이는 HTTP 요청 수를 증가시키므로 웹 성능에 부정적인 영향을 미친다.

따라서 기능단위로 모듈화 된 여러 파일들을 하나로 병합하여 HTTP 요청 수를 줄일 수 있다.

병합된 파일이 너무 크다면 다운로드하여 브라우저 화면에 나타내는 로딩이 너무 길어질 수 있기 때문에 적절한 크기를 유지해야한다.

### 3.1.2 인라인 이미지

이미지를 base64로 인코딩하여 사용하게 되면 바이트 크기가 소폭 커진다.

하지만 별도의 이미지 파일이 존재하지 않기 떄문에 캐시할 수 없고, HTML이 캐시되어야 동시에 캐시할 수 있다.

떄문에 전반적인 성능 개선 여부를 확인하고 선택사용해야 한다.

### 3.1.3 CSS 스프라이트

CSS 스프라이트는 여러개의 이미지를 하나의 이미지 파일로 결합해 필요한 이미지가 위치하는 픽셀 좌표 정보를 사용하는 방식이다.

주로 아이콘이나 작은 이미지를 사용할 때 유용하다.

background와 background-position을 사용한다.

```css
.icon {
  background: url("...");
  background-position: 0 - 64px;
}
```

## 3.2 콘텐츠 파일 크기 줄이기

콘텐츠 파일 내용은 변경하지 않으면서 크기를 줄일 수 있는 여러 기능들이 있다.

### 3.2.1 스크립트 파일 압축 전달

웹서버에서 각 웹서버가 지웒하는 방식으로 스크립트 콘텐츠를 압축하여 클라이언트에게 더 작은 크기로 내려줄 수 있따.

웹서버와 클라이언트 모두가 지원하는 압축 방식을 사용해야 한다.

HTTP 프로토콜에서 Accept-Encoding, Content-Encoding 헤더를 사용하여 압축방식에 대한 정보를 교환할 수 있다.

클라이언트가 웹서버에 요청하며 자신이 지원하는 압축 알고리즘을 헤더에 나열하여 서버에 알려준다.

```
// 클라이언트의 요청 헤더 - gzip,deflate, sdch를 지원함
Accept-Encoding: gzip, deflate, sdch

// 웹 서버의 응답헤더 - 클라이언트가 지원하는 압축 방식 중 gzip을 사용할 것을 명시함
Content-Encoding: gzip

```

### 3.2.2 스크립트 파일 최소화

HTML,JS,CSS에서 주석, 공백, 개행문자 등 실제 로직에 아무 영향도 주지 않는 부분을 제거하여 전반적인 파일 크기를 줄이는 방법이다.
가독성이 안좋아지기 때문에 보통 개발서버엔 원본을 두고 운영서버에 배포시에만 minify하는 방식을 사용한다.

다음 사이트에서 테스트해볼 수 있다.

https://www.minifier.org

### 3.2.3 이미지 파일 압축

이미지에 대한 메타데이터를 삭제하여 파일 크기를 줄일 수 있다.

다음 사이트에서 테스트 해볼 수 있다.

https://tinypng.com

### 3.2.4 브라우저가 선호하는 이미지 포맷 사용

크롬의 WebP 혹은 IE의 JPEG XR등 브라우저가 선호하는 이미지 포맷을 사용할 수 있다.

### 3.2.5 큰 파일은 작게 나누어 전송

동영상과 같은용량이 큰 파일들은 한 번에 내려받지 않고 파일의 일부분을 순서대로 다운로드 하는 부분 요청 응답 방식을 사용할 수 있다.

부분 요청 응답 방식은 웹 서버에 특정 부분 파일 전달을 지원하는 기능이 있을 때만 사용할 수 있다.

이는 응답헤더를 사용해서 확인할 수 있다.

```
Accept-Ranges : bytes
// byte 단위로 파일의 부분 지원 기능을 수락한다는 의미이다.
Content-Length : 50000000
// 해당 파일의 전체 크기가 50MB라는 정보를 클라이언트에게 알려준다.
```

위와 같이 웹 서버가 부분 파일 지원 기능을 명시하면 클라이언트는 요청헤더를 통해 특정 부분만 요청할 수 있다.

```
Range: bytes=0-1023
// 전체 파일이 아닌 처음부터 1023바이트까지의 파일만 요청한다.

Range: bytes=0-1023 5000-10000
// 여러 범위를 동시에 요청한다.
```

웹 서버에서는 이러한 요청에 상태코드 206으로 부분만 전달했음을 명시할 수 있다.

```
Content-Range: bytes 0-1023/50000000
// 전체 파일 범위중 처음부터 1023 바이트까지 전달한다는 으믜
Content-Length: 1024
현재 전달한 부분의 용량인 1023 바이트에 시작위치와 끝을 알려주는 데이터를 포함하여 1024 바이트임을 명시한다.
```

긴 영상을 재생할 때 동영상 플레이어에 보이는 조정바는 이 값을 이용하여 제작한다.

## 3.3 캐시 최적화하기

캐시는 자주 사용되는 콘텐츠나 특정 데이터 등을 임의의 저장소에 복제해두고 재사용하는 방식을 의미한다.

인터넷 상에서 캐시는 ISP 회사가 지역에 분포된 특정 시스템에 사용자와 원격 시스템 사이에서 주고받은 데이터를 캐시하고 다음 사용자에게 제공하는 방식으로 널리 사용된다.

콘텐츠를 캐시하는 이 시스템을 프록시캐시라고 부른다.

인터넷 캐시는 캐시 영역에 미리 데이터를 복사해두는 PUSH 방식과 실제 요청이 있을 때만 캐시에 저장하는 PULL 방식으로 분류된다.

PUSH 방식은 특정 시간, 특정 지역에 사용자의 요청이 과다하게 몰릴 것에 대비할 수 있다.

또한 브라우저 캐시도 있는데, 웹사이트에서 자주 바뀌지 않는 이미지나 자바스크립트, CSS 파일등은 인터넷 프록시 서버 뿐만 아니라 브라우저에도 캐시한다.

다음 접속때는 인터넷에 요청하지 않고 캐시된 콘텐츠를 사용할 수 있다.

### 3.3.1 인터넷 캐시 사용

프록시서버는 클라이언트가 처음 요청한 콘텐츠를 원본 서버에 대신 요청하여 클라이언트에게 전달해주고 이를 스스로 저장한다.

이후 다른 클라이언트가 동일한 콘텐츠를 요청했을 때 원본 서버에 접속할 필요 없이 자체 저장한 콘텐츠를 제공한다.

주로 사용자가 많은 지역에 여러 곳을 선택하여 설치한다.

이는 원본 서버로 몰릴 수 있는 트래픽을 분산한다는 장점과 물리적 거리를 줄여 응답이 빠르다는 두 가지 장점이 있다.

### 3.3.2 브라우저 캐시 사용

특정 콘텐츠가 브라우저 캐시를 사용할지 아닐지는 일반적으로 웹서버에서 결정한다.

왜냐면 브라우저에 캐시가 존재할 경우 네트워크 요청을 아예 하지 않기 때문에 브라우저 캐시를 삭제하기 번거롭기 때문이다.

웹 서버에서 Cache-Control 헤더를 사용하여 정책을 정할 수 있다.

```
// 캐시 TTL 설정
Cache-Control : max-age=<시간(초단위)>

// 중간서버에서만 적용되는 TTL 설정
Cache-Control : s-maxage=<시간(초단위)>

// 캐시하면 안 되는 콘텐츠의 헤더값
Cache-Control : no-store

// 원본 서버의 콘텐츠 변경 확인
Cache-Control : no-cache

// 캐시 가능 주기 확인
Cache-Control : must-revalidate

// 여러개를 동시에 설정할 수 도 있다.
Cache-Control : no-store, no-cache

// 모든 사람과 중간서버가 캐시할 수 있음
Cache-Control:public, max-age=...

// 브라우저 환경만 캐시할 수 있음
Cache-Control:private, max-age=...
```

## 3.4 CDN 사용하기

콘텐츠 전송 네트워크는 인터넷 상의 콘텐츠를 캐시서버 혹은 에지서버라 불리는 대용량 인터넷 캐시 영역에 저장해 사용하는 네트워크 방식이다.

즉 프록시의 일종이다.

다음과 같은 이점이 있다.

1. 원거리에 있는 콘텐츠를 전달받는 과정에서의 네트워크 지연과 패킷 손실 현상을 줄일 수 있다.

2. 가까이에 있는 에지서버에서 캐시된 콘텐츠를 전달받으므로 RTT가 줄어든다.

3. 원본서버의 과부하를 줄일 수 있다. 또한 인프라 확충에 드는 인력과 경비를 줄일 수 있다.

4. ICP를 이용한 서버 전파를 할 수 있어 캐시 콘텐츠의 재사용률이 매우 높다.

5. 모니터링 시스템을 갖추고 있어 시스템과 인적관리 비용이 절감된다.
