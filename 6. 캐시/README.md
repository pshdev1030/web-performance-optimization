# 6 캐시 최적화

## 6.1 캐시

콘텐츠 요청에 빠르게 응답하기 위해 서버와 크라이언트 사이에서 응답 콘텐츠의 사본을 저장하는 공간을 캐시라고 하고, 이 캐시를 유지하고 처리해주는 별도 서버를 캐시서버라고 한다.

웹 브라우저에는 다양한 캐시 서버가 존재한다.

| 캐시 종류           | 위치           | 이점                                                                                                                  |
| ------------------- | -------------- | --------------------------------------------------------------------------------------------------------------------- |
| 브라우저 캐시       | 브라우저       | 한 번 다운로드한 리소스를 재사용해 로딩을 빠르게함                                                                    |
| 프록시 캐시         | 브라우저와 ISP | 조직 내 사용자들이 접속하는 웹사이트의 리소스를 캐시하여 네트워크 연결과 대역폭 사용률을 감소시키고 로딩을 빠르게 함. |
| 트랜스패어런트 캐시 | ISP            | 대역폭이 낭비되는 것을 막음                                                                                           |
| 리버스 프록시 캐시  | ISP와 웹서버   | 원본서버로 향하는 트래픽 대역폭을 감소시키고 사용자 응답을 개선한다.                                                  |

## 6.2 웹 캐시 동작원리

웹 캐시는 웹서버와 웹 브라우저의 중간에 존재하면서 최초 원본 콘텐츠 요청을 최종 서버에 보내 응답을 받은 후 그 복사본을 만들어 저장하고 사용자에게 응답한다.

이후의 요청에 대해선 원본서버에 요청해서 가져오는 대신 복사본을 전달한다.

세밀하게 캐시를 컨트롤 하기 위해선 HTTP에 대한 기본 지식을 이해해야 한다.

### 6.2.1 HTTP

HTTP는 인터넷에서 데이터를 주고받기 위한 클라이언트 / 서버 모델을 따르는 프로토콜이다.

일반적으로 HTTP를 요청하는 브라우저와 콘텐츠를 제공하는 웹 서버를 클라이언트/ 서버로 인식할 수 있다.

하지만 중간에 캐시서버같은 프록시 서버가 생기면 저렇게 정의할 수 없다.

HTTP는 다음과 같은 특징이 있다.

1. 클라이언트 서버 모델로 동작한다.
2. 비연결성이며 상태를 유지하지 않는 프로토콜이다.
3. 클라이언트와 서버 간 HTTP 메시지를 주고받으며 통신한다.
4. HTTP 메시지는 헤더와 바디 부분으로 구분되어 전송된다.
5. 하위 Transport Layer 프로토콜로 TCP를 사용하는데 일반적으로 80포트를 사용한다.

HTTP 메시지는 헤더와 페이로드로 구분되며, 헤더에는 전송 및 처리에 필요한 데이터들이 포함되어 있다. 페이로드는 html, 이미지 등 서버가 실제 전송하고자 하는 데이터를 포함한다.

### 6.2.2 HTTP의 캐시 제어 방식

HTTP 1.1부터 Cache-Control 헤더를 사용하여 명시적으로 캐시를 제어할 수 있다.

HTTP/1.1에서는 캐시의 목적을 다음과 같이 두 가지로 정의한다.

1. 원본 서버로의 요청 수를 최소화한다. 네트워크 왕복 수를 줄여 응답 속도를 단축한다.
2. 완전한 콘텐츠를 응답하지 않아도 된다. 이는 네트워크 대역폭과 리소스 낭비를 줄이고 비율을 효율화한다.

#### Expire

HTTP/1.0에서는 Expire 헤더를 사용해 원본 서버 콘텐츠의 유효 기간을 지정하도록 정의하였다.
이 때 원본 서버는 Expire와 Date 헤더를 함께 보내야 하며 Date 헤더는 요청에 대한 응답이 작성된 시점을 표시한다.

캐시 유지시간 TTL(Time To Live)은 다음과 같이 구할 수 있다.

```
TTL = Expire - Date
```

Expire와 Date는 모두 원본 서버 시간을 기준으로 생성되기 때문에 아래와 같은 HTTP Date 형식으로 표현된다.

```
Mon, 15 Nov 2021 08:12:31 GMT
```

Expire 헤더는 캐시를 명시적으로 제어하지는 않지만 브라우저를 포함한 캐시 서버에서 콘텐츠를 언제까지 저장할 것인지 판단하기 위해 사용한다.

#### Cache-Control: max-age

HTTP/1.1 에서는 Cache-Control: max-age라는 헤더로 콘텐츠의 캐시 유지 시간을 정의한다.

원본 서버는 이 헤더를 사용해 캐시에서 특정 콘텐츠를 얼마나 오래 유지하고 있어야 하는지 명시적으로 사용한다.

이 기간이 지나면 캐시 서버는 우너본 서버에 해당 콘텐츠 변경 여부를 체크하거나 새로 갱신해야한다.

max-age는 유효 기간을 지정한다.

```
Cache-Control: max-age=2592000
```

두 헤더 모두 `원본 서버 콘텐츠의 캐시 TTL`을 결정하는 용도로 사용되지만 HTTP 1.0이 max-age를 지원하지 않기 때문에 두 헤더 모두 표시해야한다.

HTTP/1.1을 지원하는 캐시서버는 두 헤더가 모두 명시된 경우 Cache-Control을 우선 사용한다.

#### Cache-Control : s-maxage

s-maxage는 CDN과 같은 공용 캐시 주기를 관리한다.

s-maxage를 이용하면 사용중인 모든 CDN의 캐시 주기를 일괄적으로 설정하거나 변경할 수 있따.

그러나 CDN 업체가 지원하는지 확인해야한다.

#### ETag

ETag(Entity Tag) 헤더는 원본 서버가 리소스를 식별하기 위해 부여하는 고유 번호이다.

캐시 서버에서는 ETag를 사용하여 원본 서버의 리소스가 시간이 지나 만료되었는지, 캐시된 리소스를 갱신해야하는지 여부를 판단할 수 있다.

ETag는 따옴표 안 임의의 문자들의 조합으로 구성하며 어떤 조합이 될지는 원본서버가 결정한다.

```
ETag: "27dad37 1425fcc55e4d42a14879"
```

ETag는 Strong ETag와 Weak ETag 두 가지로 구분한다.

Weak ETag는 다음 예와 같이 사용한다.

Weak ETag는 'w/'를 붙여 이 값이 유일하지 않을 수 있지만 괜찮다는 것을 캐시서버에 전달한다.

```
ETag: w/ "0317"
```

#### Cache-Control: public

public으로 설정하면 응답은 모든 캐시 서버에 캐시될 수 있고 사용자 제한 없이 모든 사용자에게 응답이 전달될 수 있다.

#### Cache-Control : private

private로 설정하면 HTTP 요청에 대한 응답은 요청한 사용자만 캐시할 수 있고, CDN과 같은 범용 캐시 서버에서는 캐시할 수 없다.

엄밀하게는 캐시할 수 있지만 공유할 수 없다.

private는 원본 서버가 일부 응답을 특정 사용자에게만 전달하는데에 목적이 있으므로 공유되면 안된다.

결론적으로 최종 사용자의 브라우저에서만 응답을 자유롭게 캐시할 수 있다.

#### Cache-Control: no-cache

no-cache 지시자는 요청과 응답 헤더에 모두 사용할 수 있지만 약간의 의미 차이가 있다.

1. 요청헤더에 있을 경우

브라우저는 원본 서버나 그 중간에 존재하는 캐시서버들에게 캐시된 응답을 받지 않겠다는 메시지를 전달하는 것과 같다.

이 지시자가 있으면 중간에 있는 캐시 서버들은 원본 서버에 그대로 전달해 원본 서버로부터 최신의 응답을 받아 사용자에게 전달해야 한다.

max-age=0은 조건부 요청을 통해 콘텐츠에 변경이 있는지 먼저 검증하지만, no-cache는 항상 최신 응답을 받아오게 된다.

2. 응답 헤더에 있을 경우

원본 서버가 캐시 서버들에게 캐시된 응답을 보내기 전 원본 서버를 항상 확인하도록 강제한다.

즉 캐시서버는 캐시를 저장한 후 캐시 응답을 반환하기 전 조건부 요청을 원본 서버에 보내 응답 메시지가 변경되지 않았는지 항상 확인해야 한다.

즉 max-age=0과 동일하게 ㅗㄷㅇ작한다.

특정 헤더 항목만 캐시하고 싶지 않다면 지시자 옆에 캐시하고 싶지 않은 헤더들을 나열하면 된다.

```
no-cache:"Accept-Range"
```

#### Cache-Control : no-store

이 지시문은 서버가 로컬 저장소에 메시지를 저장하지 않도록 지시한다.

이 지시문의 목적은 캐시 데이터의 예기치 않은 유출을 방지하려 하는 것이다.

하지만 완벽한 보안매커니즘으로 신뢰하기는 어렵다.

### 6.2.3 캐시 유효성 체크

사용자가 특정 웹 콘텐츠에 대한 요청을 캐시로 보냈을 때 캐시에 저장되어 있는 응답의 age가 max-age값을 넘었다면 그 응답은 더 이상 신뢰할 수 없다.

하지만 콘텐츠에 아무런 변화가 없을 때에도 완전한 응답을 다시 만들어 보내는 것은 서버 자원과 네트워크 대역폭을 낭비하는 일이다.

이러한 일을 방지하고자 HTTP 표준은 조건부 요청이라는 메커니즘을 정의했다.

캐시의 TTL이 만료되었을 경우 항상 원본서버에서 완전한 콘텐츠를 받아오는 대신 TTL 주기 동안 콘텐츠에 변화가 있을 때에만 새 응답을 만들도록 요청한다.

우너본서버에서 조건부 요청을 받았다면 변경이 있을 때 200 응답코드와 변경된 콘텐츠를 보내고, 없을 경우 응답 본문 없이 304 코드만 헤더에 설정해서 보낸다.

조건부 요청은 시간을 기반으로 보내는 방법과 콘텐츠 기반으로 보내는 방법이 있다.

#### 시간 기반의 조건부 요청

원본서버의 콘텐츠가 변경되었는지 여부를 콘텐츠의 최종 변경 시간 중심으로 확인하느 방법이다.

저장된 객체가 변경되어 새로 저장되면 메타데이터로 남기고, 원본서버가 콘텐츠에 대한 응답을 만들어 보낼 때 Last-Modified라는 헤더에 최종 변경 날짜와 시간을 적어 보낸다.

```
Cache-Control : public, max-age=31536000
Last-Modified: Sat, 26 Aug 2017 14:23:11 GMT
```

캐시는 최초 요청에 대한 응답을 저장하고 TTL 시간이 지난 이후 같은 요청이 오면 조건부 요청을 보낸다.
요청을 보낼 때 If-Modified-Since 헤더를 같이 보낸다.

```
If-Modified-Since: Sat, 26 Aug 2017 14:23:11
```

#### 콘텐츠 기반의 조건부 요청

원본서버의 콘텐츠가 변경되었지 여부를 콘텐츠 고윳값 중심으로 확인하는 방법이다.

고윳값은 원본서버에서 정의하며 주로 해시로 추출한다.

이 고유값을 ETag 헤더에 넣어 검증한다.

이 헤더는 원본 서버의 시계 문제로 날짜와 시간을 파악할 수 없을 때 유용하게 사용된다.

캐시는 최초 요청에 대한 응답을 저장하고 TTL 시간이 지난 이후 같은 요청이 오면 조건부 요청을 보낸다.
요청을 보낼 때 If-none-match 헤더에 Etag값을 복사하여 원본 서버에 전송한다.

```
If-None-MAtch: "15f0fff99ed5aae4edffdd6496d7131f"
```

### 6.2.4 캐시 콘텐츠 갱신

웹 사이트가 개편되었거나 콘텐츠를 급하게 변경했다면 캐시에 저장된 복사본들을 강제로 갱신해야 사용자에게 정상적인 웹페이지를 서비스 할 수 있다.

캐시에 저장된 내용을 갱신하기 위해서 다음과 같은 두 가지 방법을 사용할 수 있다.

#### 퍼지

저장소를 완전히 지우는 방식으로 캐시 서버에서 명령어나 API를 제공한다.

하지만 한꺼번에 많은 콘텐츠를 퍼지할 경우 캐시되지 않은 많은 요청이 한꺼번에 원본서버로 몰려 서버 리소스가 많이 사용될 수 있기 때문에 원본 서버에 충분한 자원이 있는지 확인해야한다.

#### 무효화

조건부 요청을 통해 캐시된 리소스들 중 변경이 있었던 리소스들만 새로 갱신하는 방법이다.

Cache-Control 헤더를 사용해 캐시 서버의 내용을 강제로 무효화 할 수 있다.

```
Cache-Control: max-age=0, must-revalidate
```

마찬가지로 새 콘텐츠를 받아가려는 트래픽이 증가할 수 있다.

하지만 퍼지와 다르게 대부분 If-Modified-since나 if-Modified-match 요청이고, 실제 변경된 리소스에 한해서만 전체 콘텐츠가 반환되므로 대역폭 낭비를 크게 줄일 수 있다.

### 6.3 캐시 최적화 방안

캐시 사용을 최대화 할 수 있는 3가지 기본 원리

1. 최대한 많이 캐시해라
2. 최대한 오래 캐시해라
3. 최대한 가까이 캐시해라

#### 6.3.1 캐시 가능한 콘텐츠 구분하기

웹 페이지의 어떤 콘텐츠를 캐시할 수 있는지, 캐시하면 안되는지 알아야한다.

운영하고 있는 페이지는 어떻게 구성되었고, 얼마나 많은 파일들을 캐시할 수 있는지 WebPageTest를 통해 확인할 수 있다.

캐시할 수 있는 콘텐츠와 그렇지 않은 콘텐츠를 분류하기 위해선 정적인 콘텐츠와 동적인 콘텐츠로 먼저 분류해야한다.

1. 정적 콘텐츠

- URL을 호출할 때마다 변함없이 같은 응답을 주는 콘텐츠로 이미지, CSS, 자바스크립트 등이 대표적인 정적 이미지이다.

호출할 떄마다 소스코드 자체가 달라지진 않기 떄문에 정적 콘텐츠로 분류한다.

2. 동적콘텐츠

동적 콘텐츠란 사용자가 요청할 때마다 서버에 의해 다시 생성, 응답되는 콘텐츠로 서버에서는 HTTP 요청과 함께 입력 시간을 포함한 다양한 변수값에 따라 콘텐츠를 동적으로 생성하여 응답한다.

Ajax를 사용한 XHR 요청, 사이트에 로그인 했을 때 만들어지는 개인화된 웹페이지들도 대표적인 동적 콘텐츠이다.

결론적으로 캐시하기 어려운 콘텐츠들은 다음과 같다.

1. 개인화된 콘텐츠
2. API 호출이나 Ajax 요청에 대한 콘텐츠
3. Beacon 전달 또는 쿠키 설정을 위한 호출

캐시 가능한 콘텐츠는 올바른 정책을 정해 캐시해야한다.

#### 6.3.2 올바른 캐시 정책 설정하기

우선 웹사이트를 구성하는 리소스들을 같은 타입끼리 그룹화하고 아래와 같은 순서를 참고해 하위 그룹을 나누고 캐시 정책을 정한다.

1. 먼저 캐시할 수 있는 콘텐츠인지 판단한다.
   - 정적콘텐츠라도 보안에 민감한 내용등을 담은 사이트는 캐시하면 안된다.
2. 캐시할 수 있는 콘텐츠들은 매번 원본 서버에 변경 사항을 확인해야하는지 판단한다.
   - 정적이지만 변경에 민감한 콘텐츠들은 Cache-COntrol:no-cache나 Cache-Control: max-age=0을 사용한다.
3. 캐시할 콘텐츠들의 성격을 판단한다.
   - 모든 사용자들에게 사용될 수 있다면 Cache-Control: public, 개인화된 콘텐츠라면 Cache-Control: private를 사용한다.
4. 마지막으로 캐시 주기를 설정하고 max-age를 추가한다.

#### 6.3.3 캐시 주기 결정하기

캐시 주기는 어떻게 결정해야할까?

1. 캐시 주기는 콘텐츠 타입별로 다르게 설정할 수 있다.
   - 이미지나 동영상 등 미디어파일은 보통 링크 변경까지 같이 이루어지기 때문에 특별한 이유가 없다면 캐시주기를 1년정도로 길게 설정할 수 있다.
2. 링크 변경 없이 이미지 내용만 바꿔야한다면 캐시 무효화 방식으로 해당 이미지만 캐시에 업데이트한다.
   - 이미지나 미디어 파일을 제외한 CSS , 자바스크립트, 폰트 등의 다른 웹 리소스들은 변경이 얼마나 자주 일어나는지에 따라 e다르게 설정하되 가능한 길게 설정한다.
   - 변경 주기가 잦더라도 캐시하지 않는 것보다 짧더라도 캐시 주기를 정해 캐시하는 것이 성능에 유리하다.
3. 모든 정적 파일에 캐시 주기를 길게 설정하고 수동으로 캐시 주기를 관리하는 방법도 있다.
   - 쿼리스트링으로 버전 정보를 지정하여 관리하는 것이다.

no-store 보다는 nocache- max-age=0을 사용하여 변경이 있을 경우에만 캐시에 업데이트 하도록 하는것이 성능상의 이점이 있다.

#### 6.3.4 캐시에 적합한 디렉터리 구조 구성하기

1. 캐시할 수 있는 콘텐츠들을 별도의 폴더에 분류해 관리한다.

예를들어 다음과 같은 정적 콘텐츠들을 /static이란 폴더 아래 배치할 수 있다.

```
/static/image
/static/css
/static/js
```

캐시 서버를 /static/\*처럼 간소하게 설정할 수 있는 이점이 있다.

2. 캐시 주기별로 나누어 구성한다.

```
/static/js/lib
/static/js/module/A
/static/js/module/B
```

3. 동일한 파일을 여러 곳에 분산시키지 않아야 한다.

같은 파일을 다른 url에 여러개 두게되면 캐시서버에도 복사본이 생긴다.

이는 리소스 낭비로 이어진다.

#### 6.3.5 캐시 키 올바르게 사용하기

일반적으로 웹 캐시는 클라이언트가 요청하는 URL을 캐시 키로 사용한다.

- 일반적인 캐시 키 구성

```
호스트/패스?쿼리스트링
www.foekorea.com/kr/feo/optimization/myPic.jpg?width=200&height=100
```

아래 예제에서 캐시 키들은 서로 다른 객체를 참조한다.

```
www.foekorea.com/kr/feo/optimization/myPic.jpg
www.foekorea.com/jp/feo/optimization/myPic.jpg
www.foekorea.com/kr/feo/optimization/myPic.jpg?width=200&height=100
www.foekorea.com/kr/feo/optimization/myPic.jpg?width=200&height=200
```

- 캐시 오염과 캐시 충돌

원본 서버에 하나의 원본 파일만 존재하는데 캐시에 복사본이 여러개 존재하는 것을 캐시 오염이라고 한다.

캐시 충돌은 요청 URL이 하나인데 브라우저 환경에 따라 서버에서 제공하는 응답이 달라져 결국 최초 요청한 브라우저의 응답만 캐시되는 것을 의미한다.

- 캐시 오염 제거

캐시 오염은 최종 사용자에게 영향을 주지는 않지만 캐시 서버의 효율성에 큰 영향을 미칠 수 있다.

또한 캐시가 퍼지된 경우 원본 서버에 예기치 않은 트래픽 부담을 줄 수 있다.

캐시 오염을 제거하기 위한 여러 방법이 있다.

1. URL에 붙은 특정 스트링 값이 달라지더라도 응답이 항상 같다면 캐시 키에서 쿼리스트링을 무시하도록 설정해야 한다.

실제 원본에는 아무 영향을 미치지 않지만 캐시 서버에섣 두 개의 URL을 다르게 인식하므로 결과적으로 다른 복사본을 가진다.

대부분 캐시 서버에는 특정 쿼리스트링을 무시할 수 있는 설정이 있다.

2. 쿼리 스트링의 순서를 동일하게 정렬해야한다.

쿼리 스트링 순서가 달라져도 캐시는 이들을 다르게 인식한다.

3. Vary 헤더를 바르게 사용해야 한다.

Vary 헤더가 잘못 사용되었을 때 캐시는 같은 페이지의 복사본을 여러가지 캐시 키로 다르게 저장하기도 한다.

동일한 요청에도 브라우저 환경에 따라 응답 콘텐츠가 달라지는 경우 Vary 헤더는 이를 캐시서버에 환경별로 다른 콘텐츠를 캐시하도록 한다.

떄문에 환경에 상관 없이 같은 응답인 경우 Vary 헤더를 사용하지 않아야 한다.

꼭 필요한 경우가 아니라면 Vary 헤더를 사용하지 않거나 Cache-Control:private를 사용해 중간 캐시 서버에는 캐시하지 않도록 하는 것을 추천한다.

- 캐시 충돌 방지

캐시 충돌은 동적 페이지를 캐시할 때 주로 발생한다.

만약 로그인이 필요한 개인화 페이지에서 로그인 전 화면을 캐시하게 된다면 로그인 여부와 상관없이 로그인 전 페이지를 보게된다.

때문에 보통 홈페이지의 첫 HTML은 캐시하지 않는다.

일부 동적 페이지에 캐시를 사용하고자 한다면 Cache-Control: privatefh 사용자 브라우저에만 캐시하여 페이지 로딩 시간을 단축할 수 있다.

### 6.3.6 CDN 사용하기

글로벌 사용자를 대상으로 웹사이트를 운영하고 있거나 운영할 예정이라면 CDN 서비스로 콘텐츠를 사용자 가까이 캐시해 서비스 할 것을 권장한다.

CDN 서비스를 사용하면 세계 여러 지역 데이터 센터들에 리버스 프록시 캐시 서버를 두고 필요한 정적 콘텐츠들을 저장해둘 수 있다.

### 6.4 동적 콘텐츠 캐시

서버에서 동적 콘텐츠를 처리하는 시간이 전체 응답 시간 중 많은 부분을 차지한다.

이를 캐시할 수 있다면 사용자가 체감하는 응답 시간을 단축시킬 수 있다.

#### 6.4.1 동적 콘텐츠 캐시

동적 콘텐츠를 사용자에게 전달하기 위해 원본 서버는 아래의 두 가지 방법을 사용한다.

1. 동적 정보를 쿠키에 넣어 보낸다.
2. AJAX 요청으로 관련 정보를 동적으로 받아온다.

요청 쿠키, 헤더 혹은 쿼리스트링에 동적 콘텐츠에 대한 정보가 있다면 이 정보들을 캐시 키에 추가함으로서 동적 콘텐츠를 캐시할 수 있다.

사용자 로그인 페이지는 로그인 정보가 쿠키에 있는 경우와 없는 경우로 그룹화하고 쿠키가 없을 때만 캐시한다.

개인화 콘텐츠는 사생활을 침해하는 개인 정보가 포함되어 있을 수 있어, 캐시 전에 이를 확인해야 한다.

또한 캐시 서버 용량에 유의해야 한다. 개인화된 콘텐츠가 지나치게 많아서 캐시 서버의 용량이 소진되면 캐시 효율이 떨어진다.

로그인 전, 브라우저 타입, 사용자 성별에 따른 콘텐츠 등 크게 그룹화 할 수 있는 콘텐츠들에 국한해 사용하는 것을 권장한다.

### 6.4.2 POST 응답 캐시

GET은 쿼리 스트링 길이에 제한이 있고 URL이 노출되기 때문에 개인정보를 서버에 보내는 데에는 적합하지 않다.

POST는 HTTP 페이로드에 쿼리 스트링을 포함시켜 보내기 떄문에 데이터 크기에 제한이 없다.

떄문에 주로 개인정보를 보내는 데에 POST를 사용한다.

따라서 POST 메소드는 보통 브라우저 캐시나 조회 이력에 남지 않고 캐시서버에 캐시되어선 안된다.

하지만 입력 매개변수가 동일할 때 서버로 부터 항상 동일한 응답이 반환된다면, 또 그 응답 내용이 보안 측면에서 공개되어도 안전한 내용이라면 이 POST 요청/응답 역시 캐시할 수 있다.

단 캐시 키에 요청 매개 변숫값들이 모두 포함되어야 캐시 오염, 충돌같은 오류 현상을 방지할 수 있다.

또한 캐시 키에 매개변숫값들이 노출되지 않아야 하므로 MD5같은 해시 알고리즘을 이용해 타인이 쉽게 알 수 있도록 값을 암호화해야 한다.

즉 POST 요청/응답을 캐시하려면 다음과 같은 조건을 만족해야 한다.

- 매개 변숫값에 항상 같은 응답이 오는 경우
- 개인 정보가 포함되지 않은 경우
- 요청 사이즈가 크지 않은 경우

### 6.5 고급 캐시 전략

#### 6.5.1 Edge Side Include

만약 일부 컨텐츠만 동적으로 생성되는 콘텐츠라면 이를 따로 수행하고 캐시된 나머지부분과 조합하여 로딩 성능을 개선할 수 있다.

#### 6.5.2 HTML5 로컬 스토리지

브라우저 저장소를 이용해 캐시할 수 있다.

- 세션스토리지
- 로컬스토리지
- IndexedDB

로컬 스토리지는 한번 저장하면 브라우저의 세션이 종료되더라도 자동으로 삭제되지 않는다.

따라서 렌더링에 있어 중요한 CSS, 자바스크립트, 폰트 등을 저장하면 사용자가 재방문할 때 로딩 속도를 대폭 개선할 수 있따.

로컬스토리지에 저장하여 사용할 떄는 API를 통해 관련 리소스가 스토리지에 있는지 먼저 확인하고 없는 경우 사이트에 동적으로 로딩시키며 리소스를 다운로드 하면 URL을 키값으로 스토리지에 저장한다.
