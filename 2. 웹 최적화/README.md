# 2. 웹 최적화

## 2.1 웹 최적화란

웹 최적화란 최고의 웹 성능을 구현하기 위해 최고의 조건을 만드는 다양한 노력을 의미한다.

### 2.1.1 프론트엔드 최적화

프론트엔드 최적화는 웹 UI/UX에 관련된 최적화이다.

주로 HTML, JS, CSS 이미지, 타사 파일이 컨텐츠를 만들어 낼 때 최적화를 진행한다.

대표적인 기술은 다음과 같다.

- 스크립트를 병합하여 브라우저의 호출 개수를 줄임
- 스크립트 크기를 최소화해 바이트 자체를 줄임
- 스크립트를 gzip으로 압축하여 전달
- webp등으로 브라우저 이미지 형식을 최적화
- 이미지 손실, 무손실 압축
- Cache-Control 응답 헤더를 통해 브라우저 캐시를 충실히 사용
- 도메인 수를 줄여 DNS 조회를 최소화
- DNS 정보 미리 읽어오기
- CSS를 HTML 상단에, JS를 HTML의 하단에 위치시키기
- 페이지 미리 읽어오기
- 타사 스크립트가 웹 성능을 방해하지 않도록 조정

### 2.1.2 백엔드 최적화

웹 UI를 로직에 맞게 만드는 백엔드 관련 최적화이다.

대표적인 기술은 다음과 같다.

- DNS 응답이 빨라지도록 서버 증설
- DNS 응답을 빠르게 할 수 있도록 DNS 정보를 최대한 캐싱
- 웹 서버가 있는 데이터센터의 네트워크 출력/대역폭 증설
- 웹 서버, 웹 어플리케이션 서버의 CPU/RAM 증설
- 프록시 서버를 설정하여 웹 콘텐츠를 캐싱
- CDN을 사용하여 인터넷 상에 콘텐츠 캐싱
- 데이터베이스 정규화로 디스크 I/O 최적화
- 데이터베이스 캐싱으로 응답을 빠르게
- 로드밸런싱을 통해 가장 성능이 좋은 웹 서버로 요청을 연결
- 웹 어플리케이션 로직을 가볍고 빠르게 개발

### 2.1.3 프로토콜 최적화

웹 콘텐츠를 전달하는 HTTP/HTTPS 프로토콜 자체의 효과를 극대화하면 웹 서버가 클라이언트에게 콘텐츠를 최대 속도와 최저 지연시간으로 전달할 수 있다.

## 2.2 TCP/IP 프로토콜

TCP 네트워크의 대표적인 성능 지표는 대역폭과 지연시간이다.

- 대역폭 : 특정 시간 동안 얼마나 많은 네트워크 트래픽을 보낼 수 있는지 시간당 전송량
  예를들어 크기가 큰 이미지를 다운로드하려면 완료시간은 클라이언트와 서버 사이 대역폭에 영향을 받는다.

- 지연시간 : 클라이언트와 서버 간 콘텐츠를 전달하는 물리적인 시간
  일반적으로 클라이언트와 서버 사이 요청, 전달, 응답까지 걸리는 시간이다.

서버와 클라이언트 두 호스트를 왕복하는데 걸리는 지연시간은 Round Trip Time(RTT)라고 한다.

### 2.2.1 TCP 혼잡제어

TCP 네트워크의 통신량이 실제 처리량보다 많아서 문제가 발생하는 것을 TCP 혼잡 붕괴라고 한다.

인터넷에 연결된 호스트들이 최대한 많은 정보를 전달하기 위해 많은 네트워크 패킷을 보내기 때문에 발생한다.

TCP 혼잡은 패킷을 보내는 쪽에서 네트워크에서 수용할 수 있는 패킷의 양을 파악하고 그 만큼의 패킷만 보내는 약속으로 TCP 혼잡을 해결한다.

받는쪽은 패킷이 정상적으로 송신되었음을 알리는 ACK 패킷을 보내며 ACK 패킷을 받은 호스트는 지속적으로 패킷을 보낼 수 있다.

호스트가 네트워크의 상태를 파악하고 전송 속도를 조절하는 것 또한 혼잡 제어 기능 중 하나이다.

혼잡 제어의 대표 기술들은 다음과 같다.

1. 느린 시작

전송 가능한 버퍼의 양인 혼잡 윈도우의 초깃값을 작게 설정하여 전송한다.

통신을 시작할 때는 패킷을 1개, 이후 정상 수신 응답인 ACK를 받으며 패킷의 양을 2개 4개 등 곱셈 방식으로 점점 늘린다.

이를 패킷 유실이 발생하기 전까지 반복하는 방식이다.

즉 네트워크가 수용할 수 있는 혼잡 윈도우의 크기를 파악하면 그 이상의 패킷을 보내지 않는다.

이는 HTTP에서도 그대로 사용된다.

2. 빠른 재전송

빠른 재전송은 먼저 도착해야 하는 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 일단 ACK 패킷을 보내는 방식이다.

마지막 패킷의 다음 순번을 ACK에 실어 보내기 때문에 송신자는 중복을 감지할 수 있다.

중간에 패킷이 손실되어 송신자가 중복된 ACK 패킷을 받게 되면 정상적으로 전송되지 않은 패킷을 재전송한다.

중복된 패킷을 3개 받으면 반드시 손실된 패킷을 재전송하며, 혼잡 제어가 필요한 상황임을 인식해 혼잡 윈도우 창 크기를 줄이는 작업도 실행한다.

3. 흐름 제어

송신자가 데이터를 빠르게 혹은 많이 전송할 때 수신자의 버퍼가 오버플로 되는 현상을 방지하는 기술이다.

송신자가 데이터를 전송하는 속도를 애플리케이션 프로세스를 읽는 속도와 유사한 수준으로 만들어 트래픽 수신 속도를 송신 속도와 일치시키는 기술이다.

## 2.3 HTTP 프로토콜

웹은 HTTP 프로토콜을 통해 전달되므로 HTTP 성능을 개선하면 웹 성능도 향상된다.

### 2.3.1 HTTP 최적화 기술

HTTP 1.1부터 멀티호스트 기능과 클라이언트와 서버 사이에서 TCP/IP 연결을 재사용하는 기능이 추가됐다.

HTTP 1.1부터 적용된 연결 재사용과 파이프라이닝이 HTTP 최적화 기술이다.

### 2.3.2 HTTP 지속적 연결

매번 3-way handshake를 방식으로 TCP 연결을 맺고 끊으면 웹 로딩 시간에도 영향을 준다.

HTTP 지속적연결은 클라이언트와 서버가 TCP 상에서 한 번 연결되면 둘 사이의 연결이 완전히 끊어지기 전까지 맺어진 연결을 지속적으로 재사용하는 기술이다.

HTTP/1.0 에서는 Connection 헤더 및 keep-alive 속성으로 지속적인 연결을 요청했다.

```
Connection : keep-alive
```

HTTP/1.1 부터는 Connection 헤더를 사용하지 않아도 지속적 연결을 제공한다.
때문에 응답이 완료되거나 TCP 연결을 끊어야 할 경우에만 Connection 헤더를 사용한다.

HTTP/1.1에선 아래의 헤더를 자동으로 포함한다.

```
Connection : keep-alive
```

응답이 완료되었을 경우 지속적 연결을 종료한다.

```
Connection : close
```

TCP 연결이 계쏙 늘어나면 더 많은 클라이언트가 접속할 때 대처하지 못하는 상황이 발생할 수 있다.
때문에 서버의 성능을 고려해 HTTP 지속적 연결을 사용할지 결정해야 한다.

반대로 단일 시간 동안 TCP 연결 수를 줄여 서버의 CPU나 메모리 자원을 절약하고 네트워크 혼잡이나 지연을 줄이는 장점도 있다.

HTTP/2 부터는 단일 TCP 연결을 통해 스트림형태로 다수의 HTTP 요청과 응답을 주고받을 수 있는 멀티플렉싱 기술의 토대를 만들었기 떄문에 지속적 연결을 고민할 필요가 없다.

### 2.3.3 HTTP 파이프라이닝

HTTP 선입선출 방식의 단점을 극복하려는 기술이다.

기존에는 HTTP 요청와 응답이 여럿일 경우 하나의 응답이 지연되면 나머지 요청과 응답 모두 지연될 수 밖에 없는 구조였다.

HTTP 파이프라이닝은 먼저 보낸 요청의 응답이 없어도 다음 요청을 병렬적으로 수신자측에 전송하는 기술이다.

즉 빠른 로딩이 가능하다.

## 2.4 DNS

DNS는 인터넷 호스트명을 클라이언트와 서버가 이해할 수 있는 IP 주소로 변환해주는 시스템이다.

### 2.4.1 DNS의 작동원리

도메인을 IP주소로 질의하여 값을 받아오는 과정에는 도메인 구조 계층에 따라 각각의 DNS 서버들이 관여한다.
계층으로 나누어진 역할에 따라 순차적인 DNS 질의를 반복하는 과정을 반복적 질의라고 한다.

### 2.4.2 사용중인 다양한 도메인 확인 방법

크롬 개발자도구의 Source항목을 통해 어떤 도메인들이 사용되고 있는지 파악할 수 있다.

다양한 서비스들이 각 공급자 도메인을 사용하기 때문에 이를 지속적으로 모니터링 해야한다.

혹은 직접 호스팅하여 DNS 조회하는 수를 줄일 수도 있다.

### 2.4.3 웹 성능을 최적화하는 도메인 운용 방법

많은 도메인 호스트명을 사용하면 DNS 질의가 늘어나 응답시간이 길어지고 성능에 영향을 줄 수 있다.

이를 방지하기 위해선 상위도메인을 동일하게 해 DNS 질의를 적게 만들 수 있다.

이는 네임서버에 캐싱된 정보를 재사용 할 수 있어 DNS 질의 시간을 단축시킨다.

또한 인증서 발급비용과 수고도 줄일 수 있다.

HTML 에서는 DNS prefetch를 사용하여 도메인을 빠르게 조회할 수 있다.

웹 컨텐츠를 다운로드 함과 동시에 DNS를 조회하게 된다.

```
<link rel='dns-prefetch' href="..."/>
```

근데 연결까지 미리 하는 preconnect가 있어서 그거 사용하는게 나을 것 같다.

## 2.5 브라우저

브라우저는 HTTP, DNS를 사용해 사용자가 원하는 컨텐츠를 전달하는 소프트웨어이다.

### 2.5.1 브라우저의 역사와 특징

HTTP가 빠르게 컨텐츠를 전달해도, 이를 사용자에게 제공하는 브라우저가 빠르게 작동해야 웹 성능이 빠르다.

떄문에 디버깅은 주로 브라우저를 사용하여 수행한다.

### 2.5.2 네비게이션 타이밍 API

종단간 대기시간 정보를 제공한다.

window.performance 개체의 속성으로 사용할 수 있다.

### 2.5.2 네비게이션 타이밍 속성

performance.timing 이벤트 속성은 다음과 같이 정의되어 있다.

| 속성              | 이벤트                | 내용                                                                                                                                                                                                                                                                |
| ----------------- | --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Prompt for unload | navigationStart       | 이전 페이지 문서가 unload를 시작한 시점, 즉 이전 페이지의 모든 작업이 끝나고 새로운 페이지를 로딩할 준비가 완료된 시점. 이전 페이지가 없을 경우 fetchStart와 같은 값이 된다.                                                                                        |
| unload            | unloadStart           | 이전 페이지와 현재 페이지가 동일 근원일 때 unload 이벤트가 시작하는 바로 직전 시점이다.                                                                                                                                                                             |
| unload            | unloadEnd             | 이전 페이지와 현재 페이지가 동일 근원일 때 unload 이벤트를 마친 바로 다음 시점이다.                                                                                                                                                                                 |
| redirect          | redirectStart         | HTTP에서 페이지 재전송이 수행될 때의 시작지점이다.                                                                                                                                                                                                                  |
| redirect          | redirectEnd           | HTTP에서 페이지 재전송이 수행될 때의 마지막 페이지 재전송 응답의 마지막 바이트를 받은 시점이다.                                                                                                                                                                     |
| AppCache          | fetchStart            | HTTP 요청으로 새로운 리소스를 불러오기 시작하는 시점이다. 캐시를 지원한다면 캐시의 존재를 확인하는 시점이다. 캐시가 없다면 HTTP 응답으로 리소스를 받아오기 시작하는 시점이다.                                                                                       |
| DNS               | domainLookupStart     | 웹사이트 도메인 DNS로 IP검색을 시작하는 시점이다. 이미 해당 도메인에 연결된 TCP 세션이 남아있어 도메인 조회가 필요 없거나 DNS가 브라우저나 운영체제에 캐싱되어 있거나 IP 주소로 접속하는 등 도메인 조회가 발생하지 않으면 fetchStart와 동일한 값이다.               |
| DNS               | domainLookupEnd       | DNS 조회 종료 시점으로 DNS whghlrk qkftodgkwl dksgdkTekaus fetchStart와 같은 값이다.                                                                                                                                                                                |
| TCP               | connectStart          | 브라우저가 웹페이지 문서를 받기 위해 서버와 연결을 시도하는 시점이다. 이미 서버와 연결되어 있거나 원하는 콘텐츠가 캐싱되어 있거나 로컬 리소스를 이용하여 TCP 연결이 필요없는 경우라면 domainLookupEnd와 동일한 값을 가진다.                                         |
| TCP               | SecureConnectionStart | 브라우저가 웹페이지 문서를 받기 위해 서버와 연결을 시도하는 시점이다. 이미 서버와 연결되어 있거나 원하는 콘텐츠가 캐싱되어 있거나 로컬 리소스를 이용하여 TCP 연결이 필요없는 경우라면 domainLookupEnd와 동일한 값을 가진다. HTTPS를 사용하지 않는다면 값은 0이다.   |
| TCP               | connectEnd            | 브라우저가 웹페이지 문서를 받으려 연결했던 서버와 연결을 끊는 시점이다. 이미 서버와 연결되어 있거나 원하는 콘텐츠가 캐싱되어 있거나 로컬 리소스를 이용하여 TCP 연결이 필요없는 경우라면 domainLookupEnd와 동일한 값을 가진다. HTTPS를 사용하지 않는다면 값은 0이다. |
| Request           | requestStart          | 브라우저가 접속한 서버 혹은 어플리케이션 캐시 시스템에 문서를 요청한 시작시간이다. 재요청을 하는 경우 새 요청 바로 직전 시간을 표기한다.                                                                                                                            |
| Response          | responseStart         | 브라우저가 서버 혹은 캐시시스템으로부터 응답데이터의 첫 번째 바이트를 받은 시간이다.                                                                                                                                                                                |
| Response          | responseEnd           | 브라우저가 서버 혹은 캐시시스템으로부터 응답데이터의 첫 번째 바이트를 받은 시간이다.                                                                                                                                                                                |
| Processing        | domLoading            | 브라우저가 웹페이지 문서를 만들기 시작하는 시점이다.                                                                                                                                                                                                                |
| Processing        | domInteractive        | 브라우저가 웹페이지 문서 준비상태를 interactive로 변경하는 시점이다.                                                                                                                                                                                                |
| Processing        | domContentLoaded      | 웹페이지 문서에서 DOMContentLoaded이벤트가 호출되는 시점이다.                                                                                                                                                                                                       |
| Processing        | domComplete           | 웹페이지 문서가 준비상태를 complete로 변경하는 시점이다.                                                                                                                                                                                                            |
| onLoad            | loadEventStart        | 웹페이지의 load 이벤트가 발생하는 시점이다.                                                                                                                                                                                                                         |
| onLoad            | loadEventEnd          | 웹페이지의 load 이벤트가 완료된 시점이다.                                                                                                                                                                                                                           |

### 2.5.4 네비게이션 타이밍 속성값 구하기

window.performance.navigation 객체는 페이지 재전송 속성 그리고 앞뒤 이동버튼이나 URL이 어떤 페이지 로딩을 발생시키는지 확인하는 속성을 저장한다.

redirectCount로 재전송이 몇 번 발생했는지 확인할 수 있으며, type으로 해당 페이지에 어떻게 접속했는지에 관한 정보를 알 수 있다.

아래는 performanceAPI를 사용하는 예시이다.

1. 사용자가 느끼는 로딩시간

```
new Date().getTime - performance.timing.navigationStart
```

2. 전체 페이지 로딩시간

```
performance.timing.loadEventEnd - performance.timing.navigationStart
```

3. HTTP 요청에서 응답까지 걸린 시간 구하기

```
performance.timing.responseEnd - performance.timing.requestStart
```
